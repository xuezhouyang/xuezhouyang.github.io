<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR 空间扫描与重建系统</title>
    <style>
        :root {
            --primary: #00ffcc;
            --warning: #ffaa00;
            --bg: rgba(0, 10, 20, 0.85);
            --font: "SF Mono", "Roboto Mono", monospace;
        }

        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: var(--font);
            overflow: hidden;
        }

        /* 1. 顶部状态栏 (HUD) */
        #hud-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 100;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
        }

        .stat-box {
            font-size: 12px;
            line-height: 1.5;
        }

        .highlight { color: var(--primary); font-weight: bold; }

        /* 2. 扫描引导框 (中心准星) */
        #reticle-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 90;
            transition: border-color 0.2s;
        }
        #reticle-guide.active { border-color: var(--primary); background: rgba(0, 255, 204, 0.1); }

        /* 3. 底部操作栏 */
        #control-bar {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            pointer-events: auto;
        }

        button {
            background: rgba(0, 30, 40, 0.8);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 12px 24px;
            font-family: var(--font);
            font-size: 14px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        button:disabled { opacity: 0.5; border-color: #555; color: #555; }
        button.active { background: var(--primary); color: #000; }

        /* 4. 引导提示气泡 */
        #guidance-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 150%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: var(--warning);
            display: none;
            white-space: nowrap;
            border: 1px solid var(--warning);
        }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud-panel">
        <div class="stat-box">
            <div>POINTS: <span id="pt-count" class="highlight">0</span></div>
            <div>VOXELS: <span id="vox-count" class="highlight">0</span></div>
        </div>
        <div class="stat-box" style="text-align: right;">
            <div>MODE: <span id="sys-mode" class="highlight">IDLE</span></div>
            <div id="fps-counter">FPS: --</div>
        </div>
    </div>

    <!-- UI Elements -->
    <div id="reticle-guide"></div>
    <div id="guidance-toast">⚠ 角度缺失：请向右移动</div>

    <!-- Controls -->
    <div id="control-bar">
        <!-- WebXR 启动按钮将由 Three.js 生成，我们覆盖其样式 -->
        <button id="btn-scan" style="display:none;">开始扫描</button>
        <button id="btn-finish" style="display:none;">完成并漫游</button>
        <button id="btn-export" style="display:none;">导出数据</button>
    </div>

    <!-- Core Script -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        // --- 全局配置 ---
        const CONFIG = {
            maxPoints: 10000,   // 最大采样点数 (13 Ultra 可轻松处理 5w+, 这里保守设置)
            scanRate: 2,        // 每帧采样的跳过帧数 (2 = 30fps采样)
            voxelSize: 0.1,     // 空间体素网格大小 (米)
            pointSize: 0.015,   // 渲染点的大小
            colorScan: 0x00ffcc,
            colorOld: 0x008866
        };

        // --- 系统状态 ---
        let camera, scene, renderer;
        let controller;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let isScanning = false;
        let isRoamMode = false;
        let pointCloudMesh; // 实例化网格
        let pointIndex = 0;
        let dummyMatrix = new THREE.Matrix4();
        let frameCount = 0;
        
        // 空间哈希表，用于去重和计算覆盖率
        const voxelMap = new Map(); 

        // 漫游控制器
        let orbitControls;

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // 1. 场景初始化
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // 2. 灯光
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);

            // 3. 初始化点云容器 (InstancedMesh 性能优化)
            const geometry = new THREE.IcosahedronGeometry(CONFIG.pointSize, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colorScan, 
                roughness: 0.2, 
                metalness: 0.8 
            });
            // 预分配内存
            pointCloudMesh = new THREE.InstancedMesh(geometry, material, CONFIG.maxPoints);
            pointCloudMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            // 初始化所有点到无限远
            for (let i = 0; i < CONFIG.maxPoints; i++) {
                dummyMatrix.setPosition(0, -1000, 0); // 藏在地下
                pointCloudMesh.setMatrixAt(i, dummyMatrix);
            }
            scene.add(pointCloudMesh);

            // 4. WebXR 按钮配置
            const btn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body } 
            });
            btn.style.bottom = '90px'; // 调整位置，避开我们的自定义按钮
            btn.style.opacity = '0.8';
            document.body.appendChild(btn);

            // 5. 事件监听
            window.addEventListener('resize', onWindowResize);
            
            // 绑定自定义按钮
            document.getElementById('btn-finish').addEventListener('click', toggleRoamMode);
            
            // 监听 WebXR 会话状态
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);
        }

        function onSessionStart() {
            document.getElementById('sys-mode').innerText = "SCANNING";
            document.getElementById('btn-finish').style.display = 'block';
            document.getElementById('hud-panel').style.display = 'flex';
            isScanning = true;
            isRoamMode = false;
        }

        function onSessionEnd() {
            document.getElementById('sys-mode').innerText = "ENDED";
            document.getElementById('btn-finish').style.display = 'none';
            isScanning = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心逻辑：扫描与数据处理 ---

        function handleScanning(frame, session, referenceSpace) {
            // 请求 HitTest 源
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then((refSpace) => {
                    session.requestHitTestSource({ space: refSpace }).then((source) => {
                        hitTestSource = source;
                    });
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource && !isRoamMode) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);

                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitPose = hit.getPose(referenceSpace);
                    
                    // 视觉反馈：准星变亮
                    document.getElementById('reticle-guide').classList.add('active');

                    // 采样限流 (每 N 帧采集一次，避免重复点过多)
                    if (frameCount % CONFIG.scanRate === 0) {
                        addPointToCloud(hitPose.transform.position);
                    }
                } else {
                    document.getElementById('reticle-guide').classList.remove('active');
                    // 引导提示：如果检测不到平面，提示移动
                    showGuidance("距离过远或特征不足，请靠近表面");
                }
            }
        }

        function addPointToCloud(position) {
            // 1. 空间体素化去重 (Voxel Hashing)
            // 将连续的坐标离散化，如果该体素格子里已经有点，则忽略，避免点云过密
            const vx = Math.floor(position.x / CONFIG.voxelSize);
            const vy = Math.floor(position.y / CONFIG.voxelSize);
            const vz = Math.floor(position.z / CONFIG.voxelSize);
            const key = `${vx},${vy},${vz}`;

            if (voxelMap.has(key)) return; // 该区域已扫描

            // 2. 记录新点
            voxelMap.set(key, true);
            
            if (pointIndex < CONFIG.maxPoints) {
                dummyMatrix.setPosition(position.x, position.y, position.z);
                // 稍微随机化旋转，增加自然感
                dummyMatrix.makeRotationX(Math.random());
                dummyMatrix.setPosition(position.x, position.y, position.z);
                
                pointCloudMesh.setMatrixAt(pointIndex, dummyMatrix);
                pointCloudMesh.instanceMatrix.needsUpdate = true;
                
                pointIndex++;
                
                // 更新 UI
                document.getElementById('pt-count').innerText = pointIndex;
                document.getElementById('vox-count').innerText = voxelMap.size;
                
                // 隐藏引导
                hideGuidance();
            } else {
                showGuidance("点云缓冲区已满，请完成扫描");
            }
        }

        // --- 核心逻辑：漫游模式 ---

        function toggleRoamMode() {
            if (isRoamMode) return; // 已经在漫游
            
            isRoamMode = true;
            isScanning = false;
            document.getElementById('sys-mode').innerText = "ROAMING (FROZEN)";
            document.getElementById('btn-finish').style.display = 'none';
            document.getElementById('reticle-guide').style.display = 'none';

            // 退出 AR 会话，回到 3D 视图进行漫游
            // 注意：WebXR session end 会重置相机，这里我们做一个简单的处理：
            // 实际上为了在这个页面直接看，我们需要在 XR 中实现漫游或者退出 XR 
            // 鉴于单文件体验，我们选择退出 XR 并在 Canvas 上操作
            
            const session = renderer.xr.getSession();
            if(session) session.end();

            // 重新设置相机位置以便观察
            camera.position.set(0, 1.5, 2);
            camera.lookAt(0, 0, 0);

            // 启用轨道控制器
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            
            // 添加环境背景，方便观察
            scene.background = new THREE.Color(0x111111);
            
            showGuidance("已生成模型。单指旋转，双指平移");
        }

        // --- 辅助逻辑 ---

        function showGuidance(msg) {
            const el = document.getElementById('guidance-toast');
            el.innerText = msg;
            el.style.display = 'block';
        }

        function hideGuidance() {
            document.getElementById('guidance-toast').style.display = 'none';
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            frameCount++;

            if (isScanning && frame) {
                const session = renderer.xr.getSession();
                const referenceSpace = renderer.xr.getReferenceSpace();
                
                if (session && referenceSpace) {
                    handleScanning(frame, session, referenceSpace);
                }
            }

            if (isRoamMode && orbitControls) {
                orbitControls.update();
            }

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>

